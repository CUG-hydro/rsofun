---
title: "Example using LM3-PPA"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
library(dplyr)
library(tibble)
library(rsofun)
library(ggplot2)

if(!require(devtools)){install.packages(devtools)}
#devtools::install_github("stineb/rbeni")
library(ingestr)

#devtools::install_github("tidyverse/multidplyr")
library(multidplyr)
```

## Example

### Simulation settings

Manually select some sites from which we're going to use the data for evaluation and calibration.
```{r}
sitename <- "CH-Lae"
```

Create a site meta info table that contains all the site-specific information that is used to force site-simulations (e.g. starting year, number of simulations years, elevation, etc.). For FLUXNET2015 data, required meta info is provided by the `rsofun` package (data frame `rsofun::metainfo_Tier1_sites_kgclimate_fluxnet2015`).
```{r}
# Take only year 2004 to 2014, corresponding to subset of data for site CH-Lae
siteinfo <- data.frame(sitename="CH-Lae", lon = 8.365, lat = 47.47808, elv = 700, year_start = 2004, year_end = 2014, classid = NA, c4 = FALSE, whc = NA, koeppen_code = NA, igbp_land_use = "Mixed Forests", plant_functional_type = "Broadleaf trees")

siteinfo <- as_tibble(siteinfo)
siteinfo <- siteinfo %>% 
  dplyr::mutate(date_start = lubridate::ymd(paste0(year_start, "-01-01"))) %>%
  dplyr::mutate(date_end = lubridate::ymd(paste0(year_end, "-12-31")))
```

Now specify the simulation parameters that are identical for all site-scale simulations.
```{r}
params_siml <- tibble( #list
      spinup                = TRUE,
      spinupyears           = 1800, #1793,
      recycle               = 1, # 9 or 11 changed to 1 when aggregating forcing into 1 year
      firstyeartrend        = 1998, #1998
      nyeartrend            = 1, #9 or 11 (longer transient years)
      outputhourly          = TRUE,
      outputdaily           = TRUE,
      do_U_shaped_mortality = FALSE,
      update_annualLAImax   = FALSE,
      do_closedN_run        = TRUE,
      method_photosynth     = "pmodel", # gs_leuning or pmodel
      method_mortality      = "dbh" # dbh or cstarvation or growthrate or const_selfthin
      )
```

#### Photosynthesis method
The model includes two methods for estimating NPP:
(a) "gs_leuning" the original method described for the LM3-PPA (Weng et al. 2015).
(b) "pmodel" the implementation of the P-model (Stocker et al. 2020) within the LM3-PPA.
The P-model which simulates acclimated photosynthetic parameters and light use efficiency for daily time steps. 
For the implementation of the P-model in LM3-PPA, GPP is calculated at the cohort-level (not canopy-level), using light absorbed per cohort, and expressed in kg C per day and per tree (or cohort).
PAR is the amount of light reaching the respective layer (mol m-2 s-1).
fAPAR is attenuated based on the leaf area index within-crown of all layers above and on a fixed exponential light extinction (with k=0.75).
LUE is simulated as gpp per unit absorbed light (g C mol−1) and depends on a fix quantum yield efficiency parameter. (kphio Long et al., 1993). 

#### Mortality method
The model allows for four different mortality functional forms: 
(a) "dbh" as a function of size: high mortality rate for large trees (following Weng et al. 2015).
(b) "cstarvation" as a function of tree's C balance: carbon starvation as a decreasing in the cohort’s NSC level.
(c) "growthrate" as a function of growth rate: high mortality rate for faster growing trees.
(d) "const_selfthin" as a constant self-thinning relationship.

### Define model parameters

#### Tile-level parameters

```{r}
params_tile <- tibble( #list

  soiltype     = 3,     # Sand = 1, LoamySand = 2, SandyLoam = 3, SiltLoam = 4, FrittedClay = 5, Loam = 6, Clay = 7
  FLDCAP       = 0.4,   # soil property: field capacity 
  WILTPT       = 0.05,  # soil property: wilting point
  K1           = 2.0,   # turnover rate of fast SOM per year
  K2           = 0.05,  # turnover rate of slow SOM per year
  K_nitrogen   = 8.0,   # mineral Nitrogen turnover rate
  MLmixRatio   = 0.8,   # the ratio of C and N returned to litters from microbes
  etaN         = 0.025, # loss rate with runoff
  LMAmin       = 0.02,  # minimum LMA, boundary condition
  fsc_fine     = 1.0,   # fraction of fast turnover carbon in fine biomass
  fsc_wood     = 0.0,   # fraction of fast turnover carbon in wood biomass
  GR_factor    = 0.33,  # growth respiration factor
  l_fract      = 0.0,   # fraction of the carbon retained after leaf drop
  retransN     = 0.0,   # retranslocation coefficient of Nitrogen
  f_initialBSW = 0.2,
  f_N_add      = 0.02,   # re-fill of N for sapwood
  
  # add calibratable params
  tf_base      = 1,
  par_mort     = 0.6   # param_dbh=0.6 param_csv=-2 param_gr=1 CAI_MAX=2
  
  )
```

#### Species-level parameters

```{r}
params_species <- tibble(
  
  lifeform      = rep(1,16),                 # 0 for grasses; 1 for trees
  phenotype     = rep(0,16),                 # 0 for Deciduous; 1 for Evergreen
  pt            = rep(0,16),                 # 0 for C3; 1 for C4
  seedlingsize  = rep(0.05,16),              # initial size of seedlings
  LMA           = rep(0.05,16),              # Leaf mass per unit area. For sps: Beech (0.05); Spruce (0.17) Fir (0.11)
  LNbase        = rep(0.8E-3,16),            # kgN m-2 leaf, Vmax = 0.03125*LNbase
  laimax        = rep(3.5,16),               # maximum crown LAI
  LAI_light     = rep(4.0,16),               # Light-limited crown LAI
  Nfixrate0     = rep(0,16),                 # 0.03 kgN kgRootC-1 yr-1
  NfixCost0     = rep(12,16),                # 12, 24 gC/gN
  phiCSA        = rep(0.25E-4,16),           # ratio of sapwood area to leaf area
  mortrate_d_c  = rep(0.01,16),              # canopy tree mortality rate, year-1
  mortrate_d_u  = rep(0.075,16),             # understory tree mortality rate, year-1
  maturalage    = rep(5,16),                 # the age that can reproduce
  fNSNmax       = rep(5,16),                 # multiplier for NSNmax as sum of potential bl and br
  
  # add calibratable params
  kphio         = rep(0.05, 16),
  phiRL         = rep(3.5, 16)
  
  ) 
```

#### Soil parameters

By layers.
```{r}
# adopted from datatypes.mod.f90 l.538
params_soil <- tibble(
  type              = c("Coarse","Medium","Fine","CM","CF","MF","CMF","Peat","MCM"),
  GMD               = c(0.7, 0.4, 0.3, 0.1, 0.1, 0.07, 0.007, 0.3, 0.3),
  GSD               = c(5.0, 5.3, 7.4, 6.1, 6.1, 14.0, 15.0, 7.4, 7.4),
  vwc_sat           = c(0.380, 0.445, 0.448, 0.412, 0.414, 0.446, 0.424, 0.445, 0.445),
  chb               = c(3.5,6.4,11.0,4.8,6.3,8.4,6.3,6.4,6.4),
  psi_sat_ref       = c(-600, -790, -910, -1580, -1680, -1880, -5980, -790, -790), # Pa
  k_sat_ref         = c(130.8, 75.1, 53.2, 12.1, 11.1, 12.7, 1.69, 53.2, 53.2), # mol/(s MPa m)
  alphaSoil         = rep(1, 9),
  heat_capacity_dry = c(1.2e6, 1.1e6, 1.1e6, 1.1e6, 1.1e6, 1.1e6, 1.1e6, 1.4e6, 1.0)
  )
```

#### Initial cohort specification

Select the species identity of the initial cohorts and initial biomass. With `init_cohort_species = rep(2, 10)` we're selecting ten cohorts of the same species (number 2).
```{r}
init_cohort <- tibble(
 init_cohort_species = rep(2, 10),
 init_cohort_nindivs = rep(1,10),    # initial individual density, individual/m2
 init_cohort_bsw     = rep(0.05,10), # initial biomass of sapwood, kg C/individual
 init_cohort_bHW     = rep(0.0, 10), # initial biomass of heartwood, kg C/tree
 init_cohort_nsc     = rep(0.05,10)  # initial non-structural biomass
)
```

#### Initial soil pools

```{r}
# high N input --> Deciduous
# low  N input --> Evergreen
init_soil <- tibble( #list
 init_fast_soil_C    = 0.0,    # initial fast soil C, kg C/m2
 init_slow_soil_C    = 0.0,    # initial slow soil C, kg C/m2
 init_Nmineral       = 0.015,  # Mineral nitrogen pool, (kg N/m2)
 N_input             = 0.0008  # annual N input to soil N pool, kgN m-2 yr-1
)
```

### Define soil parameters

For now, this is implemented as an illustration. Should be made site-specific.
```{r}
df_soiltexture <- bind_rows(
  top    = tibble(layer = "top",    fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1),
  bottom = tibble(layer = "bottom", fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1)
)
```

### Get input

The file has the following variables (units):

```{r}
load("~/data/forcingLAE.RData")#forcingLAE See script prepare_drivers.Rmd

if (params_siml$method_photosynth == "gs_leuning"){
  forcingLAE <- forcingLAE %>% 
    dplyr::group_by(lubridate::month(date),lubridate::day(date),lubridate::hour(date)) %>% 
    summarise_at(vars(1:13), list(~mean(., na.rm = TRUE)))
  forcing <- forcingLAE[,-c(1:3)]
}

if (params_siml$method_photosynth == "pmodel" && dt_secs != (60*60*24)){
  forcingLAE <- forcingLAE %>% 
    dplyr::group_by(lubridate::month(date),lubridate::day(date)) %>% 
    summarise_at(vars(1:13), list(~mean(., na.rm = TRUE)))
  forcing <- forcingLAE[,-c(1:2)]
}
```

For P-model runs, aggregate to daily forcing.
```{r}
# Changing values of PAR for running simulations
#forcing <- forcing %>% mutate(PAR = PAR*1.30) # levels = *1, *1.15 and *1.30

# Replicating forcing data to run longer transient years
#forcing <- bind_rows(replicate(10, forcing, simplify = FALSE))
```

Collect all drivers
```{r}
df_drivers <- tibble(sitename,
                    siteinfo = list(tibble(siteinfo)),
                    params_siml = list(tibble(params_siml)),
                    params_tile = list(tibble(params_tile)),
                    params_species=list(tibble(params_species)),
                    params_soil=list(tibble(params_soil)),
                    init_cohort=list(tibble(init_cohort)),
                    init_soil=list(tibble(init_soil)),
                    forcing=list(tibble(forcing)))

```

### Run the model

Run the model for all the sites specified in the first step.
```{r}
out <- run_lm3ppa_f_bysite( sitename, 
                            params_siml, 
                            siteinfo, 
                            forcing, # ddf_input
                            params_tile, 
                            params_species, 
                            params_soil, 
                            init_cohort, 
                            init_soil,
                            makecheck = TRUE)

out <- run_lm3ppa_f_bysite( df_drivers$sitename[1], 
                            df_drivers$params_siml[[1]],
                            df_drivers$siteinfo[[1]], 
                            df_drivers$forcing[[1]], # ddf_input
                            df_drivers$params_tile[[1]], 
                            df_drivers$params_species[[1]], 
                            df_drivers$params_soil[[1]], 
                            df_drivers$init_cohort[[1]], 
                            df_drivers$init_soil[[1]],
                            makecheck = TRUE)

out$output_annual_tile %>% 
  ggplot() +
  geom_line(aes(x = year, y = GPP)) +
  theme_classic()+labs(x = "Year", y = "GPP")

out$output_annual_tile %>% 
  ggplot() +
  geom_line(aes(x = year, y = plantC)) +
  theme_classic()+labs(x = "Year", y = "plantC")

```

Run for the full set of sites

```{r}
df_output <- runread_lm3ppa_f(
     df_drivers,
     makecheck = TRUE,
     parallel = FALSE
     )
df_output$data[[1]]$output_annual_tile %>% 
  ggplot() +
  geom_line(aes(x = year, y = GPP)) +
  theme_classic()+labs(x = "Year", y = "GPP")

```

### Model calibration

#### Define calibration settings
Targets: GPP, LAI, Stand Biomass (Stem, Foliage, root), # trees
Calibration parameters: Quantum Yield Efficiency (kphio), Root:Shoot ratio (phiRL), Plant respiration (tf), mortality parameter specific of each formulation.

```{r}
# Constant Self-thinning 
settings_calib_CST <- list(
  method              = "gensa", # gensa, optimr, BayesianTools, linscale
  targetvars          = c("targets_obs"),
  timescale           = list(targets_obs = "y"),
  maxit               = 5, # (5 for gensa) (30 for optimr)
  sitenames           = "CH-Lae",
  metric              = "rmse",
  dir_results         = "./",
  name                = "ORG",
  par                 = list(kphio = list(lower=0.01, upper=0.07, init=0.02),
                             phiRL = list(lower=1, upper=8, init=2),
                             tf_base = list(lower=0.5, upper=2, init=1),
                             par_mort = list(lower=0, upper=4, init=0.5))
 )

# Mortality as DBH
settings_calib_DBH <- list(
  method              = "gensa", # gensa, optimr, BayesianTools, linscale
  targetvars          = c("targets_obs"),
  timescale           = list(targets_obs = "y"),
  maxit               = 5, # (5 for gensa) (30 for optimr)
  sitenames           = "CH-Lae",
  metric              = "rmse",
  dir_results         = "./",
  name                = "ORG",
  par                 = list(kphio = list(lower=0.01, upper=0.07, init=0.02),
                             phiRL = list(lower=1, upper=8, init=2),
                             tf_base = list(lower=0.5, upper=2, init=1),
                             par_mort = list(lower=0.01, upper=1, init=0.1))
 )

# Mortality as carbon starvation
settings_calib_NSC <- list(
  method              = "gensa", # gensa, optimr, BayesianTools, linscale
  targetvars          = c("targets_obs"),
  timescale           = list(targets_obs = "y"),
  maxit               = 5, # (5 for gensa) (30 for optimr)
  sitenames           = "CH-Lae",
  metric              = "rmse",
  dir_results         = "./",
  name                = "ORG",
  par                 = list(kphio = list(lower=0.01, upper=0.07, init=0.02),
                             phiRL = list(lower=1, upper=8, init=2),
                             tf_base = list(lower=0.5, upper=2, init=1),
                             par_mort = list(lower=-3, upper=-1, init=-2.9))
 )

# Mortality as growth rate
settings_calib_GR <- list(
  method              = "gensa", # gensa, optimr, BayesianTools, linscale
  targetvars          = c("targets_obs"),
  timescale           = list(targets_obs = "y"),
  maxit               = 5, # (5 for gensa) (30 for optimr)
  sitenames           = "CH-Lae",
  metric              = "rmse",
  dir_results         = "./",
  name                = "ORG",
  par                 = list(kphio = list(lower=0.01, upper=0.07, init=0.02),
                             phiRL = list(lower=1, upper=8, init=2),
                             tf_base = list(lower=0.5, upper=2, init=1),
                             par_mort = list(lower=0.01, upper=2, init=0.1))
 )

```

#### Get ddf_obs

TARGET 1. GPP data from FluxNet (see Euler)
FLX_CH-Lae_FLUXNET2015_FULLSET_YY_2004-2014_1-3.csv
Variable: GPP_NT_VUT_REF

```{r}
Fluxnet <- read.csv("~/data/FLUXNET-2015_Tier1/20191024/YY/FLX_CH-Lae_FLUXNET2015_FULLSET_YY_2004-2014_1-3.csv")
GPP <- Fluxnet[,c("TIMESTAMP","GPP_NT_VUT_REF")] # g C/m2/yr
# Convert in Kg C/m2/yr as in the LM3-PPA model
GPP <- GPP %>% mutate(GPP_KgC = GPP_NT_VUT_REF/1000)
mean_annual_gpp <- mean(GPP$GPP_KgC) #Kg C/m2/yr
```

TARGET 2. LAI or fAPAr from MODIS
LAI is the one-sided green leaf area per unit ground area in broadleaf canopies and as half the total needle surface area per unit ground area in coniferous canopies. 
FPAR is the fraction of photosynthetically active radiation (400-700 nm) absorbed by green vegetation. 
Both variables are used for calculating surface photosynthesis, evapotranspiration, and net primary production.

Data from Euler or downloaded here using ingestr

```{r}
# LAI
# Reading files ...
lai_LAE <- read.csv("~/data/modis_subsets/MODIS_LAI_MCD15A3H_daily_CH-Lae.csv")
mean_annual_lai <- mean(lai_LAE$modisvar, na.rm=T)
max_annual_lai <- max(lai_LAE$modisvar, na.rm=T)

# LAI
# ... or downloading with ingestr package
settings_modis <- get_settings_modis(
  bundle            = "modis_lai",
  data_path         = "~/data/modis_subsets/",
  method_interpol   = "loess",
  keep              = TRUE,
  overwrite_raw     = FALSE,
  overwrite_interpol= TRUE
  )

df_modis_lai <- ingest_bysite(
  sitename  = "CH-Lae",
  source    = "modis",
  year_start= 2018,
  year_end  = 2019,
  lon       = 8.36439,
  lat       = 47.47833,
  settings  = settings_modis,
  verbose   = FALSE
  )

# fPAR
# Reading files ...
fpar_LAE <- read.csv("~/data/modis_subsets/MODIS_FPAR_MCD15A3H_daily_CH-Lae.csv")
mean_annual_fpar <- mean(fpar_LAE$modisvar, na.rm=T)
max_annual_fpar <- max(fpar_LAE$modisvar, na.rm=T)

# fPAR
# ... or downloading with ingestr package
settings_modis <- get_settings_modis(
  bundle            = "modis_fpar",
  data_path         = "~/data/modis_subsets/",
  method_interpol   = "loess",
  keep              = TRUE,
  overwrite_raw     = FALSE,
  overwrite_interpol= TRUE
  )

df_modis_fpar <- ingest_bysite(
  sitename  = "CH-Lae",
  source    = "modis",
  year_start= 2018,
  year_end  = 2019,
  lon       = 8.36439,
  lat       = 47.47833,
  settings  = settings_modis,
  verbose   = FALSE
  )
```

TARGET 3. Total Stand Biomass 
Use equations from the Swiss NFI book pag 212 see eq for Fagus sylvatica
Use values of wood density from Forrester et al 2017. 

```{r}
LAE_alltrees <- read.csv("~/data/LWF/Laegeren/LAE_AllTrees.csv") # Data from Christof
#LAE_data <- read.csv("~/data/LWF/Laegeren/20201216_Laegeren_data.csv") # Data from Vova

wood_density_Fagus = 590 # Kg/m3
LAE_Fagus <- LAE_alltrees %>% dplyr::filter(ARTN.TEXT == "Fagus sylvatica")
LAE_Fagus <- LAE_Fagus %>% mutate(DBH_m = BHD/100) %>% mutate(StemVolume = 0.0025428 + 0.39446*DBH_m*DBH_m*HOEHE + 2.56612*DBH_m*DBH_m - 3.67034*DBH_m*DBH_m*DBH_m + 0.03567*DBH_m*DBH_m*DBH_m*HOEHE) %>% mutate(StemBiomass = StemVolume * wood_density_Fagus)
mean_biomassFagus <- mean(LAE_Fagus$StemBiomass)

LAE_Picea <- LAE_alltrees %>% dplyr::filter(ARTN.TEXT == "Picea abies")

LAE_Abies <- LAE_alltrees %>% dplyr::filter(ARTN.TEXT == "Abies alba")

```

TARGET 4. Number of trees higher than 12 cm 

```{r}
LAE_data <- read.csv("~/data/LWF/Laegeren/20201216_Laegeren_data.csv") # Data from Vova
LAE_nTrees <- LAE_data %>% group_by(INVYEAR,SPECIES) %>% summarise(nTrees=n()) %>% arrange(SPECIES)
LAE_ha <- 1.34
densityFagus <- LAE_nTrees[[12,3]]/LAE_ha
densityPicea <- LAE_nTrees[[16,3]]/LAE_ha
densityFir   <- LAE_nTrees[[2,3]]/LAE_ha
```

Prepare the observed target variables: ddf_obs

```{r}
ddf_obs <- tibble(GPP = mean_annual_gpp, LAI = max_annual_lai, Density= densityFagus, Biomass=mean_biomassFagus) %>%
  #pivot_longer(everything(), names_to = "variables", values_to = "targets_obs")
  gather("variables", "targets_obs",GPP,LAI,Density,Biomass)


data.frame(row.names= c("GPP","LAI","Density","Biomass"),targets_obs = c(mean_annual_gpp,max_annual_lai,densityFagus,mean_biomassFagus))

nrow(ddf_obs)
```

Contrast obseved vs. simulated targets

```{r}
  df_output$data[[1]]$output_annual_tile %>%
  summarise(GPP = mean(GPP), LAI= max(LAI), Density=mean(Density12), Biomass=mean(plantC)) %>%  
  #pivot_longer(everything(), names_to = "variables", values_to = "targets_mod") %>%
  gather("variables", "targets_mod",GPP,LAI,Density,Biomass) %>%
  left_join(ddf_obs)
  
```

#### Calibrate the model
```{r}

## Constant Self-thinning
set.seed(1982)
settings_calib_CST <- calib_sofun(
  df_drivers = dplyr::filter(df_drivers, sitename %in% settings_calib_CST$sitenames),  
  ddf_obs = ddf_obs,
  settings = settings_calib_CST
  )

print(settings_calib_CST$par_opt)

df_output$data[[1]]$output_annual_tile %>% 
  dplyr::summarise(GPP = mean(GPP), LAI= max(LAI), Density=mean(Density12), Biomass=mean(plantC)) %>%  
  gather("variables", "targets_mod",GPP,LAI,Density,Biomass) %>%
  # tidyr::pivot_longer(everything(), names_to = "variables", values_to = "targets_mod") %>%
  dplyr::left_join(ddf_obs)


## Mortality as tree size
set.seed(1752)
settings_calib_DBH <- calib_sofun(
  df_drivers = dplyr::filter(df_drivers, sitename %in% settings_calib_DBH$sitenames),  
  ddf_obs = ddf_obs,
  settings = settings_calib_DBH
  )

print(settings_calib_DBH$par_opt)

## Mortality as carbon starvation
set.seed(1982)
settings_calib_NSC <- calib_sofun(
  df_drivers = dplyr::filter(df_drivers, sitename %in% settings_calib_NSC$sitenames),  
  ddf_obs = ddf_obs,
  settings = settings_calib_NSC
  )

print(settings_calib_NSC$par_opt)

## Mortality as carbon starvation
set.seed(1682)
settings_calib_GR <- calib_sofun(
  df_drivers = dplyr::filter(df_drivers, sitename %in% settings_calib_GR$sitenames),  
  ddf_obs = ddf_obs,
  settings = settings_calib_GR
  )

print(settings_calib_GR$par_opt)

```

The calibrated parameters are returned by calib_sofun() as part of the list:
```{r}
print(settings_calib$par_opt)
```



