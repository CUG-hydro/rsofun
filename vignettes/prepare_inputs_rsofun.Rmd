---
title: "Prepare rsofun forcing data"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
library(rsofun)
library(ingestr)
library(tidyverse)
```

The following describes how to use the [ingestr R package ](https://stineb.github.io/ingestr/) for collecting rsofun forcing data. This is to create the object `df_drivers`, required as an input (forcing) to rsofun. This vignette is specific for collecting forcing data where no site-specific measurements are available, but all data is extracted from global maps. Head over to the vignette `prepare_fluxnetinputs_rsofun.Rmd` for an example for collecting forcing data for a FLUXNET site, using site-specific meteorological data. Note that this code requires the [tidyverse](https://www.tidyverse.org/) R package.

## Site selection and meta data

A small number of meta data variables have to be specified for each site specifically to define the simulation years and site location. This information is also used for input, calibration, and evaluation data ingestion. Required meta information is specified as a data frame with sites by rows and the following variables (by columns):

- `sitename`: any unique identifying of the site(s)
- `lat` for latitude (decimal degrees)
- `lon` for longitude (decimal degrees) - this is only used for data ingestion but not for the P-model simulation with `rsofun`.
- `elv` for elevation (m a.s.l.). If this is not known, *ingestr* may be used to extract information from a digital elevation model.
- `year_start` and `year_end` specifying years covered by the simulation. Data extraction and model simulations always cover all 365 days of each year.
- `whc` for the total rooting zone soil water holding capacity. This is not a temporary "fudge" solution. Set it to 170 mm if no better information is available.
- `koeppen_code` to group sites for evaluation by Koeppen-Geiger climate zones (may be ignored, only required for `eval_sofun()`).

The following is an example (`elv` is not specified) for small ensemble of site simulations (*N* = 3):
```{r}
siteinfo <- tibble(
  sitename = c("s1", "s2", "s3"),
  lon = c(100.05, 100.45, 90),
  lat = c(50, 50, 50),
  elv = c(1000, 250, 2500),
  year_start = c(2003, 2001, 2005),
  year_end = c(2007, 2008, 2009),
  whc = 200
)
siteinfo
```

Note that sites "s1" and "s2" are located close to each other - within 0.5 degrees in longitude and on the same latitude. Climate forcing used in this example (see below) is from the WATCH-WFDEI reanalysis data, provided at 0.5 degrees. This implies that sites "s1" and "s2" are forced with the same climate (but different fAPAR data). To speed up climate data ingest, we can determine the 0.5 degrees gridcells containing at least one site and ingest respective data. These steps are explained in Section *Forcing by gridcell*. Below, we continue explaining simulations with forcing by site. This facilitates the coding greatly (while dealing with larger amount of climate forcing data, which slows it down) ...

## Get model forcing time series

Input data, used as model forcing, is collected using the [ingestr](https://stineb.github.io/ingestr/) package. A brief description for how to use it for our present application is provided here. Data is collected by data source. 

### Climate forcing

This extracts from original WATCH-WFDEI files, provided as NetCDF (global, 0.5 degree resolution), provided as monthly files containing all days in each month. The data directory specified here (dir = `"~/data/watch_wfdei/"`) contains sub-directories with names corresponding to WATCH-WFDEI variable names (e.g. `"Tair"`). The variables for which data is to be ingested, is given by the argument `getvars`. See the [ingestr](https://stineb.github.io/ingestr/) website for a list of standard variable names. For P-model simulations with rsofun, we typically use the variables indicated below. An additional variable (cloud cover fraction) is read from CRU TS data, for which a data ingest option is also available in the  ingestr package.

For multiple sites, data is ingested as follows.
```{r message=FALSE, warning=FALSE, eval=FALSE}
ddf_watch <- ingest(
  siteinfo = siteinfo,
  source    = "watch_wfdei",
  getvars   = c("temp", "prec", "ppfd", "vpd"),
  dir       = "~/data/watch_wfdei/"  # adjust this with your local path
)
save(ddf_watch, file = "~/rsofun/data/ddf_watch.RData")

ddf_cru <- ingest(
  siteinfo = siteinfo,
  source    = "cru",
  getvars   = "ccov",
  dir       = "~/data/cru/ts_4.01/"  # adjust this with your local path
)
save(ddf_cru, file = "~/rsofun/data/ddf_cru.RData")
```

The data objects `ddf_watch` and `ddf_cru` are organised as a nested table with rows for sites and time series nested inside the column `data`. See [here](https://tidyr.tidyverse.org/reference/nest.html) for how to handle nested data frames. 

Now, Combine the two meteo data frames into one, containing `ccov` (cloud cover) from CRU and all other variables from WATCH-WFDEI
```{r}
ddf_meteo <- df_watch %>% 
  tidyr::unnest(data) %>% 
  left_join(
    ddf_cru %>% 
      tidyr::unnest(data),
    by = c("sitename", "date")
  ) %>% 
  group_by(sitename) %>% 
  tidyr::nest()
```

### fAPAR data

fAPAR data is prescribed in the P-model setup. MODIS data can be ingested either using the [MODISTools](https://docs.ropensci.org/MODISTools/) R package from MODIS LP DAAC (see a complete description [here](https://stineb.github.io/ingestr/articles/example.html#modis-lp-daac-1)), or from MODIS data hosted on Google Earth Engine using the [gee_subset](https://github.com/bluegreen-labs/gee_subset) R package. The former provides full functionality and subsetting larger areas, including multiple pixels. The latter works much faster but allows only data ingest for single pixels. Chose the appropriate for your application. Both are available through the [ingestr](https://stineb.github.io/ingestr/) R package.

#### MODISTools

The following example is for downloading MODIS collection 6, MCD15A3H, band `Fpar_500m` data.
```{r}
settings_modis <- get_settings_modis(
  bundle            = "modis_fpar",
  data_path         = "~/data/modis_subsets/",
  method_interpol   = "loess",
  keep              = TRUE,
  overwrite_raw     = FALSE,
  overwrite_interpol= TRUE
  )

df_modis_fpar <- ingest(
  siteinfo, 
  source = "modis",
  settings = settings_modis, 
  parallel = FALSE,
  ncores = 2
  )
```

Plot this for a quick check using the function `plot_fapar_ingestr_bysite()` from the ingestr package. **WARNING: FOR MODIS_FPAR, NO FILTERING IMPLEMENTED YET.**
```{r}
library(ggplot2)
plot_fapar_ingestr_bysite(
  df_modis_fpar,
  settings_modis)
```

To make this output consistent for use below, let's nest it and rename the desired column to `fapar` (this is a bit weird, sorry)
```{r}
df_modis_fpar <- df_modis_fpar %>% 
  rename(fapar = modisvar_filled) %>%
  group_by(sitename) %>% 
  nest()
```

#### gee_subsets

This requires authentication with Google Earth Engine. See [here](https://stineb.github.io/ingestr/articles/example.html#google-earth-engine) for a guide of required steps. Once, this is done, do the following.
```{r}
settings_gee <- get_settings_gee(
  bundle            = "modis_fpar",
  python_path       = system("which python", intern = TRUE),
  gee_path          = "~/google_earth_engine_subsets/gee_subset/",    # adjust this with your local path
  data_path         = "~/data/gee_subsets/",    # adjust this with your local path
  method_interpol   = "linear",
  keep              = TRUE,
  overwrite_raw     = FALSE,
  overwrite_interpol= TRUE
  )

df_gee_modis_fpar <- ingest(
  siteinfo= siteinfo,
  source  = "gee",
  settings= settings_gee,
  verbose = FALSE
  )
```

## CO2

Ingesting CO2 data is particularly simple. We can safely assume it's well mixed in the atmosphere (independent of site location), and we can use a annual mean value for all days in respective years.  
```{r}
df_co2 <- ingestr::ingest(
  siteinfo,
  source  = "co2_mlo",
  verbose = FALSE
  )
```

## Simulation settings

Specify additional simulation parameters that are identical for all site-scale simulations in multi-site runs, 
```{r}
params_siml <- list(
  spinup             = TRUE,      # to bring soil moisture to steady state
  spinupyears        = 10,        # number of spinup years. 10 is enough for soil moisture.
  recycle            = 1,         # number of years recycled during spinup 
  soilmstress        = FALSE,     # boolean for whether soil moisture stress function is included
  tempstress         = FALSE,     # boolean for whether temperature stress function is included
  calc_aet_fapar_vpd = FALSE,     # set to FALSE - should be dropped again
  in_ppfd            = TRUE,      # if available from forcing files, set to TRUE
  in_netrad          = FALSE     # if available from forcing files, set to TRUE
  )
```

<!-- Run `prepare_setup_sofun()` to define the simulation settings that contain all the information specified by the two steps above (meta info, and simulation parameters), global simulation parameters are wrapped inside an additional column `params_siml`, added to the site meta info dataframe. -->
<!-- ```{r} -->
<!-- siteinfo <- prepare_setup_sofun(siteinfo = siteinfo, params_siml = params_siml) -->
<!-- ``` -->

## Define model parameters

Specify model parameters based on prior model calibration. See `benchmarking/tag_v*/benchmark_gpp_FLUXNET2015_ensemble.html` for latest calibrations.
```{r}
params_modl <- list(
  kphio           = 0.09423773,
  soilm_par_a     = 0.33349283,
  soilm_par_b     = 1.45602286
  )
```

## Define soil parameters

For now, this is implemented as an illustration. Should be made site-specific. Values entered here take no effect.
```{r}
df_soiltexture <- bind_rows(
  top    = tibble(layer = "top",    fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1),
  bottom = tibble(layer = "bottom", fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1)
)
```

## Collect all drivers

Finally, we can collect forcing data, simulation parameters, and site meta info into a single object that will be used to drive rsofun. All of the above steps can be customized. The function `collect_drivers_sofun()` can in general be used to process forcing data into the format required to run SOFUN. The arguments must have the following form:

- `siteinfo`: A data frame (tibble) with columns `sitename`, `lon`, `lat`, `elv` (elevation), `year_start`, `year_end`, `whc` (water holding capacity used for simulating the soil water balance). We have created this above.
```{r} 
siteinfo
```
- `meteo`: A nested data frame with columns `sitename` and `data`. The latter contains the nested meteorological forcing data frames, with columns `date`, `temp`, `prec`, `vpd`, `ppfd`, `patm`, and `ccov`. Like this:
```{r}
## nested data frame:
ddf_meteo

## inside .$data:
ddf_meteo$data[[1]] %>% dplyr::select(-ccov_int)
```


- `fapar`: A nested data frame with columns `sitename` and `data`. The latter contains the nested meteorological forcing data frames, with columns `date`, and `fapar`. Like this:
```{r}
## nested data frame:
df_modis_fpar

## inside .$data:
df_modis_fpar$data[[1]] %>% dplyr::select(date, fapar)
```
- `co2`  : A nested data frame with columns `sitename` and `data`. The latter contains the nested meteorological forcing data frames, with columns `date`, and `co2`. Like this:
```{r}
## nested data frame:
df_co2

## inside .$data:
df_co2$data[[1]] %>% dplyr::select(date, co2)
```
- `df_soiltexture`: See above ('Define soil parameters')

See [here](https://tidyr.tidyverse.org/reference/nest.html) for how to handle nested dataframes. 

Finally, all input data can be collected by:
```{r}
df_drivers <- collect_drivers_sofun( 
  siteinfo       = siteinfo,
  params_siml    = params_siml,
  meteo          = ddf_meteo, 
  fapar          = df_modis_fpar,
  co2            = df_co2,
  df_soiltexture = df_soiltexture
  )
df_drivers
```

