---
title: "Example for using rsofun"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include=FALSE}
library(rsofun)
library(dplyr)
library(readr)
library(ingestr)
```

## Example using rsofun for P-model simulations

The following describes the use of `rsofun` for an ensemble of site-scale P-model simulations, including steps for model calibration and evaluation (benchmarking). `rsofun` is designed in a modular and hierarchical fashion. This enables multiple setups within the same modelling framework. The P-model implementation in `rsofun` is described in Stocker et al. (2020) *Geosci. Mod. Dev.*. 

In the P-model setup, the model requires time series of daily meteorological data as input and is calibrated against observational GPP data. This example describes simulations at a subset of FLUXNET 2015 Tier 1 sites, using GPP based on the night-time flux partitioning method as calibration target and benchmark (no worries, an out-of-sample calibration/evaluation function is available, too). 

### Site selection and meta data

We manually define a subset of sites that are part of the FLUXNET 2015 Tier 1 set of sites:
```{r}
# mysites <- c("BE-Vie", "DE-Tha", "DK-Sor", "FI-Hyy", "IT-Col", "NL-Loo", "US-MMS", "US-WCr", "US-UMB", "US-Syv", "FR-Pue")
mysites <- "FR-Pue"
```

A small number of meta data variables have to be specified for each site specifically to define the simulation years. This information is also used for input, calibration, and evaluation data ingestion. Required meta information is specified for each site (in rows) and a number of variables:

- `lat` for latitude (decimal degrees)
- `lon` for longitude (decimal degrees) - this is only used for data ingestion but not for the P-model simulation with `rsofun`.
- `elv` for elevation (m a.s.l.)
- `year_start` and `year_end` specifying years covered by the simulation
- `whc` for the soil water holding capacity
- `koeppen_code` to group sites for evaluation by Koeppen-Geiger climate zones.

This information is provided in file `siteinfo_fluxnet2015.csv`. This file is created as described in (and using code from) [metainfo_fluxnet2015](https://github.com/stineb/metainfo_fluxnet2015). 
```{r}
siteinfo <- readr::read_csv("~/rsofun/siteinfo_fluxnet2015.csv") %>%
  dplyr::filter(sitename %in% mysites)

## take only year 2007 to 2014, corresponding to subset of data for site FR-Pue provided in this package as demo
siteinfo <- siteinfo %>% 
  dplyr::mutate(year_start = 2007, year_end = 2014)

siteinfo <- siteinfo %>% 
  dplyr::mutate(date_start = lubridate::ymd(paste0(year_start, "-01-01"))) %>%
  dplyr::mutate(date_end = lubridate::ymd(paste0(year_end, "-12-31")))
```

### Simulation settings

<!-- Create a site meta info table that contains all the site-specific information that is used to force site-simulations (e.g. starting year, number of simulations years, elevation, etc.). For FLUXNET2015 data, required meta info is provided by the `rsofun` package (data frame `rsofun::metainfo_Tier1_sites_kgclimate_fluxnet2015`). -->
<!-- ```{r} -->
<!-- path_siteinfo <- "~/siteinfo_example_fortran.csv" -->
<!-- siteinfo <- rsofun::metainfo_Tier1_sites_kgclimate_fluxnet2015 %>%  -->
<!--   dplyr::filter(sitename %in% mysites) %>% -->
<!--   write_csv(path = path_siteinfo) -->
<!-- ``` -->

Specify additional simulation parameters that are identical for all site-scale simulations.
```{r}
params_siml <- list(
  spinup             = TRUE,
  spinupyears        = 10,
  recycle            = 1,
  soilmstress        = FALSE,
  tempstress         = FALSE,
  calc_aet_fapar_vpd = FALSE,
  in_ppfd            = TRUE,
  in_netrad          = FALSE,
  outdt              = 1,
  ltre               = FALSE,
  ltne               = FALSE,
  ltrd               = FALSE,
  ltnd               = FALSE,
  lgr3               = TRUE,
  lgn3               = FALSE,
  lgr4               = FALSE
	)
```

Run `prepare_setup_sofun()` to define the simulation settings that contain all the information specified by the two steps above (meta info, and simulation parameters), global simulation parameters are wrapped inside an additional column `params_siml`, added to the site meta info dataframe.
```{r}
siteinfo <- prepare_setup_sofun(siteinfo = siteinfo, params_siml = params_siml)
```

### Define model parameters

First, let's do it by hand (calibration of parameters is shown later).
```{r}
params_modl <- list(
	kphio           = 0.05,
	soilm_par_a     = 1.0,
	soilm_par_b     = 0.0,
	vpdstress_par_a = 0.2,
	vpdstress_par_b = 0.2,
	vpdstress_par_m = 5
	)
```

### Define soil parameters

For now, this is implemented as an illustration. Should be made site-specific. Values entered here take no effect.
```{r}
df_soiltexture <- bind_rows(
  top    = tibble(layer = "top",    fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1),
  bottom = tibble(layer = "bottom", fsand = 0.4, fclay = 0.3, forg = 0.1, fgravel = 0.1)
)
```

### Get input

Input data, used as model forcing, is collected using the [ingestr](https://stineb.github.io/ingestr/) package. A brief description for how to use it for our present application is provided here. Data is collected by data source. 

#### Meteo data

The following ingests meteorological data from the FLUXNET 2015 files for variables temperature, precipitation, VPD, shortwave incoming radiation, net radiation, and atmospheric pressure. Arguments that are specific for this data source are provided in the `settings` list. The data object `ddf_fluxnet` is organised as a nested table with rows for sites and time series nested inside the column `data`. See [here](https://tidyr.tidyverse.org/reference/nest.html) for how to handle nested dataframes. 
```{r message=FALSE, warning=FALSE}
library(ingestr)
ddf_fluxnet <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source    = "fluxnet",
  getvars   = list(temp = "TA_F", prec = "P_F", vpd  = "VPD_F", ppfd =  "SW_IN_F", patm = "PA_F"),
  dir       = "~/data/FLUXNET-2015_Tier1/20191024/DD/",
  settings  = list(dir_hh = "~/data/FLUXNET-2015_Tier1/20191024/HH/", getswc = FALSE),
  timescale = "d"
  )
```

Some meteo data is not available from FLUXNET. Extract it from CRU global climate files instead.
```{r}
ddf_cru <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source    = "cru",
  getvars   = list(ccov = "cld"),
  dir       = "~/data/cru/ts_4.01/"
  )
```

Combine the two meteo data frames into one, containing `ccov` (cloud cover) from CRU and all other variables from FLUXNET.
```{r}
ddf_meteo <- ddf_fluxnet %>% 
  tidyr::unnest(data) %>% 
  left_join(
    ddf_cru %>% 
      tidyr::unnest(data),
    by = c("sitename", "date")
  ) %>% 
  group_by(sitename) %>% 
  tidyr::nest()
```

#### fAPAR data

fAPAR data is prescribed in the P-model setup. The following extracts data MODIS FPAR data from Google Earth Engine (see a complete description for how to set up the GEE API and download library [here](https://stineb.github.io/ingestr/articles/example.html#google-earth-engine)). 

The following example is for downloading MODIS FPAR data (MODIS/006/MCD15A3H, band Fpar). 
```{r}
settings_gee <- get_settings_gee( 
  bundle = "modis_fpar", 
  python_path = system("which python", intern = TRUE),
  gee_path = "~/google_earth_engine_subsets/gee_subset/",
  data_path = "~/data/gee_subsets/",
  method_interpol = "linear",
  keep = FALSE,
  overwrite_raw = FALSE,
  overwrite_interpol = TRUE
  )
```

This can now be used to download the data to the directory specified by argument `data_path` of function `get_settings_gee()` and to read data into R.
```{r}
df_gee_modis_fpar <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source = "gee",
  settings = settings_gee,
  verbose = FALSE
  )
```

#### CO2

Ingesting CO2 data is particularly simple. We can safely assume it's well mixed in the atmosphere (independent of site location), and we can use a annual mean value for all days in respective years.  
```{r}
df_co2 <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source = "co2",
  verbose = FALSE,
  settings = list(path = "~/data/co2/cCO2_rcp85_const850-1765.csv")
  )
```

#### Collect all drivers

Finally, we can collect forcing data, simulation parameters, and site meta info into a single object that will be used to drive rsofun.
```{r}
df_drivers <- collect_drivers_sofun( 
  siteinfo       = siteinfo %>% dplyr::filter(sitename %in% mysites),
  meteo          = ddf_meteo, 
  fapar          = df_gee_modis_fpar,
  co2            = df_co2,
  df_soiltexture = df_soiltexture
  )
df_drivers
```

If the data ingestion failed, an example for the drivers data frame `df_driver` can be 


### Run the model

Run the model for all the sites specified in the first step.
```{r}
## run for a single site
mod <- run_sofun_f_bysite( 
  df_drivers$sitename[1], 
  df_drivers$params_siml[[1]], 
  df_drivers$siteinfo[[1]], 
  df_drivers$forcing[[1]], 
  df_drivers$df_soiltexture[[1]], 
  params_modl = params_modl, 
  makecheck = TRUE 
  )

## Run for the full set of sites
ptm <- proc.time()
df_output <- runread_sofun_f(
     df_drivers, 
     params_modl = params_modl, 
     makecheck = TRUE,
     parallel = FALSE
     )
print(ptm)

# microbenchmark::microbenchmark(
#   runread_sofun_f(
#     df_drivers, 
#     params_modl = params_modl, 
#     makecheck = TRUE,
#     parallel = TRUE,
#     ncores = 4
#     ),
#   runread_sofun_f(
#     df_drivers, 
#     params_modl = params_modl, 
#     makecheck = TRUE,
#     parallel = FALSE
#     ),
#   times = 5,
#   units = 's'
# )

library(ggplot2)
df_output$data[[1]] %>% 
  ggplot(aes(x=date, y=gpp)) +
  geom_line() + 
  labs(title = df_output$sitename[[1]], subtitle = "SOFUN output")
```

### Calibrate

Define calibration settings.
```{r}
settings_calib <- list(
  method              = "gensa",
  targetvars          = c("gpp"),
  timescale           = list( gpp = "d" ),
  maxit               = 5, # (5 for gensa) (30 for optimr)    #
  sitenames           = "FR-Pue",
  metric              = "rmse",
  dir_results         = "./",
  name                = "ORG",
  par                 = list( kphio = list( lower=0.03, upper=0.07, init=0.0496 ) )
 )
```

Use the [ingestr](https://github.com/stineb/ingestr) package once again, now for collecting calibration target data. I.e., GPP based on the nighttime flux decomposition method.
```{r warning=FALSE, message=FALSE}
settings_ingestr_fluxnet <- list(
  dir_hh = "~/data/FLUXNET-2015_Tier1/20191024/HH/", 
  getswc = FALSE,
  filter_ntdt = TRUE,
  threshold_GPP = 0.8,
  remove_neg = FALSE
  )

ddf_fluxnet_gpp <- ingestr::ingest(
  siteinfo = dplyr::filter(siteinfo, sitename == "FR-Pue"),
  source    = "fluxnet",
  getvars = list(gpp = "GPP_NT_VUT_REF",
                 gpp_unc = "GPP_NT_VUT_SE"),
  dir = "~/data/FLUXNET-2015_Tier1/20191024/DD/",
  settings = settings_ingestr_fluxnet,
  timescale = "d"
  )
```

Calibrate the model.
```{r warning=FALSE, message=FALSE}
set.seed(1982)
settings_calib <- calib_sofun(
  df_drivers = dplyr::filter(df_drivers, sitename %in% settings_calib$sitenames),  # use only one site
  ddf_obs = ddf_fluxnet_gpp,
  settings = settings_calib
  )
```

The calibrated parameters are returned by `calib_sofun()` as part of the list:
```{r}
print(settings_calib$par_opt)
```


### Evaluate

Run the model once again with these parameters and evaluate results.
```{r warning=FALSE, message=FALSE}
params_modl$kphio <- settings_calib$par_opt["kphio"]

df_output <- runread_sofun_f(
     df_drivers, 
     params_modl = params_modl, 
     makecheck = TRUE,
     parallel = FALSE
     )
```


Get evaluation data (benchmarking data).
```{r message=FALSE, warning=FALSE}
## get data for idfferent time scales separately
settings_fluxnet <- list(
  getswc = FALSE,
  filter_ntdt = TRUE,
  threshold_GPP = 0.8,
  remove_neg = FALSE
  )

ddf_eval <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source    = "fluxnet",
  getvars   = list(gpp = "GPP_NT_VUT_REF",
                   gpp_unc = "GPP_NT_VUT_SE"),
  dir       = paste0(path.package("rsofun"), "/extdata/"),
  settings  = settings_fluxnet,
  timescale = "d"
  )

mdf_eval <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source    = "fluxnet",
  getvars   = list(gpp = "GPP_NT_VUT_REF",
                   gpp_unc = "GPP_NT_VUT_SE"),
  dir       = paste0(path.package("rsofun"), "/extdata/"),
  settings  = settings_fluxnet,
  timescale = "m"
  )

adf_eval <- ingest(
  siteinfo  = siteinfo %>% dplyr::filter(sitename %in% mysites),
  source    = "fluxnet",
  getvars   = list(gpp = "GPP_NT_VUT_REF",
                   gpp_unc = "GPP_NT_VUT_SE"),
  dir       = paste0(path.package("rsofun"), "/extdata/"),
  settings  = settings_fluxnet,
  timescale = "y"
  )
```

Use rsofun to create a standardised object used for benchmarking the model output.
```{r}
settings_eval <- list(
  benchmark = list( gpp = c("fluxnet") ),
  sitenames = mysites,
  agg       = 8  # An integer specifying the number of days used to define the width of bins for daily data aggregated to several days
  )
obs_eval <- collect_obs_eval( 
  siteinfo = siteinfo %>% dplyr::filter(sitename %in% mysites),
  settings = settings_eval, 
  adf = adf_eval, 
  mdf = mdf_eval, 
  ddf = ddf_eval 
  )
```

`obs_eval` is now a list of data frames for different temporal resolutions. The data frames have rows for sites and time series for each site nested inside the column `data`. 

`df_output` is the model output, also a data frame with rows for sites and time series for each site nested inside a column named `data`.

And finally do the evaluation.
```{r warning=FALSE, message=FALSE}
out_eval <- eval_sofun( 
  df_output, 
  settings_eval, 
  settings_sims, 
  obs_eval = obs_eval, 
  overwrite = TRUE, 
  light = FALSE 
  )
```

Print some results.
```{r}
out_eval$gpp$fluxnet$metrics$xdaily_pooled
```

Get the [rbeni](https://github.com/stineb/rbeni) R package for nice plotting functions that can be used with the output of `eval_sofun()`.
```{r}
library(rbeni)
gg <- out_eval$gpp$fluxnet$data$xdf %>% 
  analyse_modobs2("mod", "obs", type = "heat")
gg$gg +
  labs(title = "FR-Pue: modelled vs. observed GPP", 
       x = expression(paste("Modelled GPP (gC m"^{-2}, "d"^{-1}, ")")), 
       y = expression(paste("Observed GPP (gC m"^{-2}, "d"^{-1}, ")")))
```
